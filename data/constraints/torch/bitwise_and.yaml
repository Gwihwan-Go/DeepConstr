alias: torch.bitwise_and
constraints:
  input:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
  other:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
  out:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: false
infered_history: []
infered_times: 44
package: torch
pass_rate: 0.85
rules:
- cot: 'Error is triggered because the ''out'' tensor shape doesn''t match with the
    operation result shape. In this operation, the result shape is derived from ''input''
    and ''other''. Therefore, left : out.shape, out.rank op : == right : input.shape,
    other.shape'
  target: Trying to resize storage that is not resizable
  txt: (out.shape == (input.shape[0], other.shape[1])) and (out.rank==input.rank and
    all(out.shape[i]==input.shape[i] for i in range(out.rank)) and out.rank==other.rank
    and all(out.shape[i]==other.shape[i] for i in range(other.rank)))
- cot: 'The error is due to an invalid operation being performed on data types. The
    function ''bitwise_and_cpu'' is not implemented for ''Float'' data type. From
    the args, ''input'', ''other'', ''out'' are Tensors of types float32, int64 and
    float32 respectively. The ''bitwise_and_cpu'' cannot be performed on float type
    tensors, it requires integer type tensors. Therefore, the data type of ''input'',
    ''other'' & ''out'' should be corrected. They should be of integer type like int64.
    Therefore, type(input), type(other), type(out) should be corrected. Op : ==, and
    Right : int64. Also, Op : !=, and Right : float32.'
  target: '"bitwise_and_cpu" not implemented for ''Float'''
  txt: (((type(other) != float32)) or ((type(out) == int64))) or (((type(input) ==
    int64)) or ((type(out) == int64))) or (((type(other) != float32)) or ((type(out)
    == int64)))
- cot: 'The error is triggered because result type Float cannot be cast to the Long.
    Let''s see the what''s args were. The dtype of ''input'' is float32 and the dtype
    of ''other'' and ''out'' is int64. Therefore, the dtypes of the arguments should
    be consistent. Left : type(input), op : ==, comparator : type(other) or type(out)'
  target: result type Float can't be cast to the desired output type Long
  txt: (type(input)==type(other)) and (type(other)==type(out))
time_cost: 16932.40133047104
title: torch.bitwise_and
tokens_used: 26789
trained: true
