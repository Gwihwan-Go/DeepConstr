alias: torch.tril
constraints:
  diagonal:
    default: 0
    dtype: int
    init: false
    required: false
  input:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
  out:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: false
infered_history: []
infered_times: 31
package: torch
pass_rate: 1.0
rules:
- cot: 'Error is triggered because we are trying to resize storage. Let''s see what
    the args were. Here, ''input'' and ''out'' tensors are involved. It seems the
    ''out'' tensor needs to have the same shape as the ''input'' tensor in order to
    avoid resizing. Therefore, left : out.shape, op : ==, right : input.shape.'
  target: Trying to resize storage that is not resizable
  txt: (len(out.shape) >= len(input.shape)) and (all(out.shape[i]==input.shape[i]
    for i in range(len(input.shape))))
- cot: 'The error is triggered because the input tensor for the ''tril'' function
    does not have at least 2 dimensions. In this case, the input tensor only has 1
    dimension. Therefore, Left : len(input.shape), op : >=, right : 2.'
  target: 'tril: input tensor must have at least 2 dimensions'
  txt: len(input.shape) >= 2
- cot: 'Based on the problem, it is clear that the ''out'' tensor''s datatype is not
    matching with the expected datatype. The expected datatype is complex64 but the
    provided datatype is float32. Therefore, Left : out.dtype, which refers to the
    datatype of ''out'' tensor, should be corrected. It says that should be equal
    to the datatype of ''input'' tensor, so Op : ==, and Right : input.dtype.'
  target: Expected out tensor to have dtype c10::complex<float>, but got float instead
  txt: out.dtype==input.dtype
time_cost: 2343.7839839458466
title: torch.tril
tokens_used: 17354
trained: true
