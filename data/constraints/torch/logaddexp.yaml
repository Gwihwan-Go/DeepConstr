constraints:
  input:
    default: 'null'
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
  other:
    default: 'null'
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
  out:
    default: 'null'
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: false
infered_history: []
infered_times: 46
package: torch
pass_rate: 0.4
rules:
- cot: 'Error is triggered because we are trying to resize a tensor (''out'') which
    is not resizable. Let''s see what the args were. It seems that the shapes of the
    ''input'', ''other'', and ''out'' tensors are not consistent. In this operation,
    the shape of ''out'' should match the result of the operation on ''input'' and
    ''other''. So, left : out.shape, out.rank op : == right : input.shape, input.rank'
  target: Trying to resize storage that is not resizable
  txt: (out.rank==input.rank and all(out.shape[i]==input.shape[i] for i in range(out.rank)))
    or (input.rank==other.rank and all(input.shape[i]==other.shape[i] for i in range(input.rank)))
- cot: 'The error is triggered because the result type Float cannot be cast to the
    desired output type Int. What the args were? The ''input'', ''other'' and ''out''
    are tensors of type float32, float32 and int32 respectively. The output tensor
    type ''int32'' is not compatible with the input tensor types ''float32''. Therefore,
    the output tensor type should be changed to ''float32'' to match the input tensor
    types. So, Left : type(out), Op : ==, Right : float32.'
  target: result type Float can't be cast to the desired output type Int
  txt: (out.shape==other.shape) or (type(out)==float32)
- cot: 'Error is triggered because size of tensor a and tensor b at non-singleton
    dimension 2 doesn''t match. Let''s see what the args were? It is a size mismatch
    between ''input'' and ''other'' at non-singleton dimension 2. The size of ''input''
    at dimension 2 is 10, and the size of ''other'' at dimension 2 is 4. They should
    have been the same. Therefore, we can revise the constraints as follows:'
  target: The size of tensor a (10) must match the size of tensor b (4) at non-singleton
    dimension 2
  txt: (all(input.shape[i] == other.shape[i] or input.shape[i] == 1 or other.shape[i]
    == 1 for i in range(-1, -min(len(input.shape), len(other.shape))-1, -1))) and
    ((input.shape[2] == other.shape[2]) or ((input.shape[4] == other.shape[4]) and
    (input.shape[2] == other.shape[2])))
time_cost: 19778.988897800446
title: torch.logaddexp
tokens_used: 30796
trained: true
