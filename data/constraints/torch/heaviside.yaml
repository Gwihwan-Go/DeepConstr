alias: torch.heaviside
constraints:
  input:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
  out:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: false
  values:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
infered_history: []
infered_times: 33
package: torch
pass_rate: 1.0
rules:
- cot: 'Error is triggered because it attempts to resize an unresizable storage. Let''s
    see what the args were. The ''values'' tensor seems to be the source of the problem.
    The ''values'' tensor shape does not match with the ''out'' tensor shape. Therefore,
    left: values.shape, values.rank, op: ==, right: out.shape, out.rank'
  target: Trying to resize storage that is not resizable
  txt: (out.shape == input.shape) and ((values.rank==out.rank and all(values.shape[i]
    == out.shape[i] for i in range(values.rank))) and ((len(out) == len(input)*len(values))
    and ((all(values.shape[i]==input.shape[i] for i in range(values.rank))) and (all(values.shape[i]
    == out.shape[i] for i in range(values.rank))))))
- cot: 'The error is due to the use of the function ''heaviside'' on tensors with
    different data types. The ''heaviside'' function is not yet implemented for tensors
    with different data types. Looking at the types of the tensors, ''input'' and
    ''values'' tensors are of type float32 whereas ''out'' tensor is of type int32.
    This difference in types is causing the error. Therefore, the data type of ''out''
    tensor should be corrected to match the data type of ''input'' and ''values''
    tensors. The data type of ''out'' tensor should be float32. So, Left : out.dtype,
    Op : ==, and Right : tf.float32. Also, the data type of ''input'' and ''values''
    tensor should be the same. So, Left : input.dtype, Op : ==, and Right : values.dtype.'
  target: heaviside is not yet implemented for tensors with different dtypes.
  txt: (type(input) == type(out)) and (input.dtype == values.dtype)
- cot: 'The problem is that the heaviside function is not implemented for complex
    tensors. In the provided values, ''input'', ''out'', and ''values'' are all complex64
    tensors. To avoid triggering the error, ''input'', ''out'', and ''values'' should
    not be of complex type. Therefore, type(input), type(out), and type(values) should
    be real types. Op : not in, and Right : ["complex64", "complex128"].'
  target: heaviside is not yet implemented for complex tensors.
  txt: type(values) not in ["complex64", "complex128"]
time_cost: 21739.92462491989
title: torch.heaviside
tokens_used: 22381
trained: true
