alias: torch.index_select
constraints:
  dim:
    default: null
    dtype: int
    init: false
    required: true
  index:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
  input:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
  out:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: false
infered_history: []
infered_times: 44
package: torch
pass_rate: 0.02
rules:
- cot: 'The error is caused because the ''dim'' value is out of the expected range.
    According to the error message, the ''dim'' value can range from -1 to 0, but
    in the provided values, ''dim'' is -2. Therefore, the constraint should be that
    the variable ''dim'' needs to be in the range of -1 to 0. Hence, Left : dim, Op
    : >= , Right : -1 and Left : dim, Op : <= , Right : 0.'
  target: Dimension out of range (expected to be in range of [-1, 0], but got -2)
  txt: ((dim < len(index.shape)) and (dim >= -1)) or ((dim >= -1) and (dim <= 0))
    or ((dim < len(index.shape)) and (dim >= -1))
- cot: "The error is triggered because an attempt is made to resize a storage that\
    \ is not resizable. From the given values, it seems like the 'out' Tensor is the\
    \ storage in question. Here, the operation is likely attempting to modify the\
    \ 'out' tensor's shape to match the shape of the 'input' tensor. This operation\
    \ is not permitted because the 'out' tensor is not resizable. Therefore, the shape\
    \ of 'out' must already match the 'input' shape for the operation to proceed without\
    \ errors.\n\nSo the constraint is:\n\n`out.shape == input.shape`\n\nwhich translates\
    \ to \n\n`all(out.shape[i] == input.shape[i] for i in range(len(input.shape)))`.\n\
    \nAlso, it appears that 'dim' and 'index' are being used in the operation, possibly\
    \ for indexing into the 'input' tensor. The value of 'dim' must be valid i.e.,\
    \ within the range of the 'input' tensor's rank. The 'index' tensor's shape must\
    \ also match the 'input' tensor's shape along the 'dim' dimension.\n\nSo the additional\
    \ constraints are:\n\n`0 <= dim < len(input.shape)`\n\nand \n\n`index.shape[0]\
    \ == input.shape[dim]`\n\nwhich translates to \n\n`0 <= dim < len(input.shape)\
    \ and index.shape[0] == input.shape[dim]`.\n\nCombined, the constraints are:"
  target: Trying to resize storage that is not resizable
  txt: (all(out.shape[i] == input.shape[i] for i in range(len(input.shape)))) and
    ((out.rank == input.rank) and (index.shape[0] == input.shape[dim]))
- cot: 'The error arises because the index tensor is supposed to be a vector. Let''s
    see what the args were. Here, the ''index'' tensor is of shape [4, 10, 1], which
    is not a vector. Therefore, the rank of ''index'' tensor should be 1. So, Left
    : index.rank, and Right : 1.'
  target: 'index_select(): Index is supposed to be a vector'
  txt: index.rank == 1
- cot: 'The error is due to an invalid index data type. Let''s check the args. It
    seems ''index'' tensor dtype is int8 but the function index_select() expects int32
    or int64. Therefore, the dtype of ''index'' tensor should be corrected, which
    is ''index''.dtype. Therefore, Left : ''index''.dtype. The expected data types
    are int32 or int64, so Op : ==, and Right : int32 or int64.'
  target: 'index_select(): Expected dtype int32 or int64 for index'
  txt: '''index''.dtype == ''int32'' or ''index''.dtype == ''int64'''
time_cost: 4372.810362577438
title: torch.index_select
tokens_used: 27548
trained: true
