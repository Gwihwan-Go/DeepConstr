constraints:
  name:
    default: 'null'
    dtype: str
    init: false
    required: false
  x:
    default: null
    dtype: int8,int16,int32,int64,uint8,uint16,uint32,uint64
    init: false
    required: true
  y:
    default: null
    dtype: int8,int16,int32,int64,uint8,uint16,uint32,uint64
    init: false
    required: true
infered_history:
- 4
- 1
- 4
- 4
infered_times: 14
package: tf
pass_rate: 0.18
rules:
- cot: 'Based on the provided values, the error arises because the attribute of ''x''
    and ''y'' is a float, but it is expected to be one of int8, int16, int32, int64,
    uint8, uint16, uint32, uint64. The tensors ''x'' and ''y'' are both provided as
    float32, which is not compatible. So, the Left : type(x) or type(y) should be
    corrected to match one of the allowed types. Op : in, and Right : [int8, int16,
    int32, int64, uint8, uint16, uint32, uint64].'
  target: "Value for attr 'T' of float is not in the list of allowed values: int8,\
    \ int16, int32, int64, uint8, uint16, uint32, uint64\n ; NodeDef: ; Op z:T; attr=T:type,allowed=[DT_INT8,\
    \ DT_INT16, DT_INT32, DT_INT64, DT_UINT8, DT_UINT16, DT_UINT32, DT_UINT64]> [Op:LeftShift]\
    \ name:"
  txt: type(x) in ["int8", "int16", "int32", "int64", "uint8", "uint16", "uint32",
    "uint64"] and type(y) in ["int8", "int16", "int32", "int64", "uint8", "uint16",
    "uint32", "uint64"]
- cot: 'The error arises because the function is trying to perform a operation on
    a int16 tensor and a uint32 tensor. However, both tensors in generated args must
    have the same data type. Let''s see what the args were. the ''x'' tensor is uint16,
    but the ''y'' tensor is of type uint64. Therefore, Left : type(y), which is the
    type of tensor y, should be corrected. It says that should be equal to the datatype
    of tensor x, so Op : ==, and Right : type(x).'
  target: 'cannot compute LeftShift as input #1(zero-based) was expected to be a int16
    tensor but is a uint32 tensor [Op:LeftShift] name:'
  txt: type(y) == type(x)
- cot: 'The error says that the input for a dynamic binary or n-ary operation was
    of a rank greater than 5. Looking at the values, both ''x'' and ''y'' are tensors
    with ranks greater than 5. Therefore, both ''x'' and ''y'' should have ranks less
    than or equal to 5 to avoid this error. So, for ''x'' and ''y'', the Left : <symbol>.dim,
    Op : <=, and Right : 5.'
  target: 'Input for dynamic binary or n-ary op lowering was of a rank greater than
    5 [Op:LeftShift] name:'
  txt: x.dim <= 5
- cot: The error is due to the shapes of ''x'' and ''y'' not being broadcastable for
    the LeftShift operation. Broadcasting in tensor operations requires that the trailing
    dimensions of the tensors are either 1 or the same. So, the constraint should
    be that for each dimension starting from the last, the size of the dimension in
    ''x'' should be equal to the size of the dimension in ''y'' or one of them should
    be 1. Since ''x'' and ''y'' are both 1D tensors with different lengths, they are
    not broadcastable. Hence the constraint should be that len(x) == len(y) or len(x)
    == 1 or len(y) == 1.
  target: 'required broadcastable shapes [Op:LeftShift] name:'
  txt: len(x) == len(y) or len(x) == 1 or len(y) == 1
time_cost: 435.88393211364746
title: tf.raw_ops.LeftShift
tokens_used: 9974
trained: true
