constraints:
  name:
    default: null
    dtype: str
    init: false
    required: false
  x:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
  y:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
infered_history: []
infered_times: 0
package: tf
pass_rate: 0.84
rules:
- cot: 'The error is due to ''T'' having an incompatible data type in ''args''. ''T''
    has a value of ''float'' which does not fall under the expected data types which
    include: int8, int16, int32, int64, uint8, uint16, uint32, uint64. Therefore,
    the type of ''T'' contained in ''x'' or ''y'' should be checked and corrected
    accordingly. Looking at ''args'', ''x'' has the type complex64 and ''y'' has the
    type int32. Hence, Left : type(x) and type(y), should be checked. Operation :
    in, and Right : [int8, int16, int32, int64, uint8, uint16, uint32, uint64].'
  target: "Value for attr 'T' of float is not in the list of allowed values: int8,\
    \ int16, int32, int64, uint8, uint16, uint32, uint64\n ; NodeDef: ; Op z:T; attr=T:type,allowed=;\
    \ is_commutative=true> name:"
  txt: type(x) in [int8, int16, int32, int64, uint8, uint16, uint32, uint64] and type(y)
    in [int8, int16, int32, int64, uint8, uint16, uint32, uint64]
- cot: 'The error comes up because the operation is trying to perform on an int8 tensor
    and a uint8 tensor. However, both tensors in the created args should have the
    same data type. Let''s see what the args were. The ''x'' tensor is of int8, but
    the ''y'' tensor is of uint8. Thus, Left : type(y), which is the type of tensor
    y, should be corrected. It needs to be equivalent to the datatype of tensor x,
    so Op : ==, and Right : type(x).'
  target: 'cannot compute BitwiseXor as input #1(zero-based) was expected to be a
    int8 tensor but is a uint8 tensor name:'
  txt: type(y)==type(x)
- cot: 'The error is due to an input tensor having a rank (number of dimensions) greater
    than 5. Both tensors ''x'' and ''y'' are considered, therefore, the dimension
    of both tensors should be checked. Therefore, Left : len(x.shape) which is the
    rank of tensor x, and Left : len(y.shape) which is the rank of tensor y, should
    be corrected. It says that cannot be greater than 5 so Op : <=, and Right : 5
    for both.'
  target: 'Input for dynamic binary or n-ary op lowering was of a rank greater than
    5 name:'
  txt: len(x.shape) <= 5 and len(y.shape) <= 5
- cot: 'The error is due to the shapes of the tensors ''x'' and ''y'' not being broadcastable.
    The shapes of ''x'' and ''y'' are [9,4] and [4,1] respectively. Broadcasting in
    tensor operations is a way for tensors of different shapes to be used together
    in operations. For broadcasting to work, the dimensions of the tensors should
    either be equal or one of them should be 1. Therefore, to prevent this error,
    the dimensions of ''y'' should be corrected. The shape of ''y'' should either
    be equal to ''x'' or should contain 1 in place of a dimension that ''x'' doesn''t
    have. Therefore, Left : y.shape, which is the shape of ''y'' should be corrected.
    It says that should be broadcastable with ''x''. So, Op : == or == 1, and Right
    : x.shape or 1.'
  target: 'required broadcastable shapes name:'
  txt: (all(y.shape[i] == x.shape[i] or y.shape[i] == 1 for i in range(len(y.shape))))
    and ((all(x.shape[i] == y.shape[i] or x.shape[i] == 1 or y.shape[i] == 1 for i
    in range(len(x.shape)))) or (all(x.shape[i] == y.shape[i] or x.shape[i] == 1 for
    i in range(len(x.shape)))))
time_cost: 0.018529176712036133
title: tf.raw_ops.BitwiseXor
tokens_used: 0
trained: true
