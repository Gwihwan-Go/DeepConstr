constraints:
  dy:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
  name:
    default: null
    dtype: str
    init: false
    required: false
  y:
    default: null
    dtype: float16,float32,float64,uint8,complex64,complex128,int8,int16,int32,int64,bool
    init: false
    required: true
infered_history:
- 6
- 16
- 16
infered_times: 38
package: tf
pass_rate: 0.66
rules:

- cot: 'The error occurs because the function ''SigmoidGrad'' is expecting a float
    tensor as input but is receiving a integer tensor. Let''s see what the args were.
    The ''y'' tensor is float32, but the ''dy'' tensor is of type int16. Therefore,
    Left : type(dy), which is the type of tensor dy, should be corrected. It says
    that should be equal to the datatype of tensor y, so Op : ==, and Right : type(y).'
  target: 'cannot compute SigmoidGrad as input #1(zero-based) was expected to be a
    float tensor but is a uint8 tensor name:'
  txt: type(dy)==type(y)
- cot: 'The error is due to an incorrect data type for ''T''. The current value for
    ''T'' is int8 which is not in the list of allowed data types: bfloat16, half,
    float, double, complex64, complex128. Therefore, type(T) should be corrected to
    be either bfloat16, half, float, double, complex64, or complex128, which is [bfloat16,
    half, float, double, complex64, complex128]. Op : in, and Right : [bfloat16, half,
    float, double, complex64, complex128]. This constraint applies to the tensors
    ''dy'' and ''y''.'
  target: "Value for attr 'T' of int8 is not in the list of allowed values: bfloat16,\
    \ half, float, double, complex64, complex128\n ; NodeDef: ; Op z:T; attr=T:type,allowed=>\
    \ name:"
  txt: type(y) in [bfloat16, half, float, double, complex64, complex128]

skipped: True
skipped_reason: unsupport constraints (numels)
time_cost: 4257.029951810837
title: tf.raw_ops.SigmoidGrad
tokens_used: 25270
