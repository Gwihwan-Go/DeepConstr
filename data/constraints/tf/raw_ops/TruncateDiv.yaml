constraints:
  name:
    default: null
    dtype: str
    init: false
    required: false
  x:
    default: null
    dtype: bfloat16,float16,float32,float64,uint8,int8,uint16,int16,int32,uint32,uint64,int64,complex64,complex128
    init: false
    required: true
  y:
    default: null
    dtype: bfloat16,float16,float32,float64,uint8,int8,uint16,int16,int32,uint32,uint64,int64,complex64,complex128
    init: false
    required: true
infered_history:
- 5
- 6
- 2
- 5
infered_times: 18
package: tf
pass_rate: 0.16
rules:
- cot: 'The error occurs because the function is trying to perform an operation on
    a uint64 tensor and an int64 tensor. However, both tensors in generated args must
    have the same data type. Let''s see what the args were. The ''x'' tensor is uint32,
    but the ''y'' tensor is of type uint16. Therefore, Left : type(x), which is the
    type of tensor x, should be corrected. It says that should be equal to the datatype
    of tensor y, so Op : ==, and Right : type(y).'
  target: 'cannot compute TruncateDiv as input #1(zero-based) was expected to be a
    uint64 tensor but is a int64 tensor [Op:TruncateDiv] name:'
  txt: type(x)==type(y)
- cot: 'The error is due to the rank of the input tensor being greater than 5. Here,
    the tensor ''x'' has a rank of 10 and tensor ''y'' has a rank of 3. So, tensor
    ''x'' triggers the error. Therefore, Left : x.rank, which is the rank of the tensor
    ''x'', should be corrected. It says that x.rank must not be greater than 5, so
    Op : <=, and Right : 5. Also for ''y'', Left : y.rank, Op : <=, and Right : 5.'
  target: 'Input for dynamic binary or n-ary op lowering was of a rank greater than
    5 [Op:TruncateDiv] name:'
  txt: ((x.rank <= 5)) and ((y.rank <= 5))
- cot: 'The error is caused by the input tensor having a rank greater than 5. The
    rank of a tensor is the number of dimensions it has. In this case, both ''x''
    and ''y'' have a rank of 1, which is less than 5. Therefore, there is no need
    to change the dimensions of ''x'' or ''y''. However, it is still possible that
    the operation ''TruncateDiv'' is not supported for tensors of rank greater than
    5. To prevent this error from occurring again, one can limit the rank of input
    tensors to 5 or less. '
  target: 'required broadcastable shapes [Op:TruncateDiv] name:'
  txt: x.dim <= 5 and y.dim <= 5
- cot: 'The error is due to the operation being performed on tensors with a rank greater
    than 5. Let''s look at the arguments. Both x and y tensors have a rank greater
    than 5. Therefore, we need to correct the dimensions of the tensors x and y. So,
    the Ops : ''<='', and Right : 5 for both x and y.'
  target: 'Incompatible shapes: [8,5,6,1,3] vs. [9,6,6,8,1] [Op:TruncateDiv] name:'
  txt: len(y.shape) <= 5
- cot: The error is because the rank (number of dimensions) of either 'x' or 'y' tensor
    is greater than 5. Therefore, the constraint to prevent this error should be that
    the length of the shape of both 'x' and 'y' should be less than or equal to 5.
    In other words, len(x.shape) <= 5 and len(y.shape) <= 5. However, this constraint
    still triggered the error with tensors having shapes [2, 3, 10, 10, 10] and [5,
    8, 5, 6, 6]. Therefore, in addition to the constraint on the lengths of shapes,
    the dimensions of the shapes should not exceed a certain limit. Let's assume this
    limit as 10. Hence, the constraints should be len(x.shape) <= 5, len(y.shape)
    <= 5 and all dimensions in x.shape and y.shape should be less than or equal to
    10.
  target: "Could not find device for node: = TruncateDiv[T=DT_COMPLEX128]\nAll kernels\
    \ registered for op TruncateDiv:\n device='XLA_GPU_JIT'; T in [DT_FLOAT, DT_DOUBLE,\
    \ DT_INT32, DT_UINT8, DT_INT16, DT_INT8, DT_COMPLEX64, DT_INT64, DT_BFLOAT16,\
    \ DT_UINT16, DT_COMPLEX128, DT_HALF, DT_UINT32, DT_UINT64]\n device='XLA_CPU_JIT';\
    \ T in [DT_FLOAT, DT_DOUBLE, DT_INT32, DT_UINT8, DT_INT16, DT_INT8, DT_COMPLEX64,\
    \ DT_INT64, DT_BFLOAT16, DT_UINT16, DT_COMPLEX128, DT_HALF, DT_UINT32, DT_UINT64]\n\
    \ device='GPU'; T in [DT_DOUBLE]\n device='GPU'; T in [DT_FLOAT]\n device='GPU';\
    \ T in [DT_HALF]\n device='GPU'; T in [DT_UINT64]\n device='GPU'; T in [DT_UINT32]\n\
    \ device='GPU'; T in [DT_INT8]\n device='GPU'; T in [DT_INT64]\n device='GPU';\
    \ T in [DT_INT16]\n device='GPU'; T in [DT_UINT16]\n device='GPU'; T in [DT_UINT8]\n\
    \ device='CPU'; T in [DT_DOUBLE]\n device='CPU'; T in [DT_FLOAT]\n device='CPU';\
    \ T in [DT_BFLOAT16]\n device='CPU'; T in [DT_HALF]\n device='CPU'; T in [DT_INT64]\n\
    \ device='CPU'; T in [DT_INT32]\n device='CPU'; T in [DT_INT16]\n device='CPU';\
    \ T in [DT_INT8]\n device='CPU'; T in [DT_UINT64]\n device='CPU'; T in [DT_UINT32]\n\
    \ device='CPU'; T in [DT_UINT16]\n device='CPU'; T in [DT_UINT8]\n [Op:TruncateDiv]\
    \ name:"
  txt: len(x.shape) <= 5 and len(y.shape) <= 5 and all(i <= 10 for i in x.shape) and
    all(i <= 10 for i in y.shape)
time_cost: 2777.594866514206
title: tf.raw_ops.TruncateDiv
tokens_used: 11616
trained: true
